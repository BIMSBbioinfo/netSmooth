---
title: "netsmooth: example with a toy dataset"
author: "Jonathan Ronen"
date: "`r Sys.Date()`"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{netSmooth example}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r setup, include=FALSE}
require(netsmooth)
require(pheatmap)
require(igraph)
```

netsmooth lets you easily use a network, such as a protein-protein interaction network, to smooth quantitative values associated with the network nodes, such as gene expression. This vignette demonstrates the idea using a toy dataset.

## The network

We'll define a netwok with 5 modules of highly interconnected genes, with rarer connections between the genes. The adjacency matrix will have a clear block-diagonal form:

```{r}
set.seed(1)
N_genes <- 600
N_samples <- 500
N_blocks = 5
blocksize_genes <- N_genes / N_blocks
blocksize_samples <- N_samples / N_blocks

adj_matrix <- matrix(rbinom(N_genes*N_genes,1,.001), ncol=N_genes)
for(i in 1:N_blocks) {
    genes.in.block <- (((i-1)*blocksize_genes)+1):(i*blocksize_genes)
    adj_matrix[genes.in.block, genes.in.block] <- matrix(rbinom(blocksize_genes*blocksize_genes,1,.1), ncol=blocksize_genes)
}
rownames(adj_matrix) <- colnames(adj_matrix) <- paste0('gene', 1:N_genes)
pheatmap(adj_matrix, cluster_rows = FALSE, cluster_cols = FALSE, show_rownames = FALSE, show_colnames = FALSE)
```
And the force-directed layout of the graph will look clustery, like this:
```{r}
graph <- igraph::graph_from_adjacency_matrix(adj_matrix, mode = "undirected")

plot(graph, vertex.label=NA)
```

Next, let's define gene expression for a group of samples, each with genes from one of the gene modules above expressed slightly higher than the background noise:

```{r}
set.seed(2)
gene_expression <- matrix(rpois(N_samples*N_genes,1), ncol=N_samples)
rownames(gene_expression) <- rownames(adj_matrix)
colnames(gene_expression) <- paste0('sample', 1:N_samples)
for(i in 1:N_blocks) {
    samples.in.block <- (((i-1)*blocksize_samples)+1):(i*blocksize_samples)
    genes.in.block <- (((i-1)*blocksize_genes)+1):(i*blocksize_genes)
    gene_expression[genes.in.block, samples.in.block] <- matrix(rpois(blocksize_genes*blocksize_samples,1.3), ncol=blocksize_samples)
}
pheatmap(log2(gene_expression+1), show_rownames = FALSE, show_colnames=FALSE, cluster_rows = FALSE, cluster_cols = FALSE)
```

There is some signal visible in the heatmap when it is ordered correctly, but it is impossible to tease out the structure cluster from the data without knowing it a-priori:

```{r}
pheatmap(log2(gene_expression+1), show_rownames = FALSE, show_colnames=FALSE, cluster_rows = TRUE, cluster_cols = TRUE)
```


We can also use the `robustClusters` function in netsmooth to find clusters in the data:


```{r}
yhat <- robustClusters(gene_expression, dimReduceFlavor='pca')
```

```{r}
df <- data.frame(robustCluters=factor(yhat$clusters))
pheatmap(log2(gene_expression[,order(df$robustCluters)]+1), cluster_rows = FALSE, cluster_cols = FALSE, show_rownames = FALSE, show_colnames = FALSE, annotation_col = df)
```
and as expected, these aren't highly informative. A `robustCluter` assignment of -1 means the sample could not be assigned to a cluster that is statistically robust.


## The netSmooth procedure

Now let's use the `netSmooth` function to propagate the expression status of genes via their network. This way, we can use the knowledge of expected coexpression among the genes in the submodules of the network, in order to strengthen the signal/noise ratio:

```{r}
gene_expression_smoothed <- netSmooth(gene_expression, adj_matrix, alpha=0.9, normalizeAdjMatrix='columns')

df=data.frame(block=factor(c(sapply(1:N_blocks, function(x) rep(x, blocksize_samples)))))
rownames(df) <- colnames(gene_expression_smoothed)

cm <- pheatmap(log2(gene_expression_smoothed+1), cluster_rows = TRUE, cluster_cols = TRUE, show_rownames = FALSE, show_colnames = FALSE, annotation_col=df)
```
The expression patterns of the samples now look much cleaner, and we've managed to re-capture much of the cluster structure. If we cut this tree at 10 clusters:

```{r}
yhat_hclust <- cutree(cm$tree_col, k=10)
df2 <- data.frame(block=df$block, yhat.hclust=factor(yhat_hclust))
pheatmap(log2(gene_expression_smoothed+1), cluster_rows = TRUE, cluster_cols = TRUE, show_rownames = FALSE, show_colnames = FALSE, annotation_col=df2)
```

## The robustClusters procedure

While the hierarchical clustering above recapitulates much of the original structure, two of the structures seem to be a mixture of sample types, and the clusters themselves aren't perfectly clean. We can use the `robustClusters()` function in order to find cluster structure in the data which is cleaner and avoids assigning cluster labels to samples which are still noisy and thus hard to place:

```{r}
yhat.sm <- robustClusters(gene_expression_smoothed, dimReduceFlavor='pca', combineManyProportion=.6, combineManyMinSize=10)
```

we get robust clusters for most of the samples:

```{r}
o <- order(yhat.sm$clusters)
pheatmap(gene_expression_smoothed[,o], cluster_rows = FALSE, cluster_cols = FALSE, show_rownames = FALSE, show_colnames = FALSE,
         annotation_col = data.frame(robustClusters=as.factor(yhat.sm$clusters), yhat.hclust=df2$yhat.hclust, block=df$block))

```

The robustClusters mostly mirror the hierarchical clusters, and the set of noisy samples has been left unclustered (robustCluster=-1).

We can quantify this by looking at the mutual information between the different cluster labels and the ground truth:

```{r}
nmi <- function(a,b){
    NMI::NMI(data.frame(1:length(a), a), data.frame(1:length(b), b))
}
data.frame(clustering=c('hclust','robustClusters'), nmi=unlist(c(nmi(df2$block, yhat_hclust), nmi(df2$block[yhat.sm$clusters!=-1], yhat.sm$clusters[yhat.sm$clusters!=-1]))))

```


## What if there were no signal in the gene expression matrix at all?
Would `netSmooth` still produce clusters? Let's define the same gene expression matrix as above, but without any block diagonal signal:

```{r}
set.seed(2)
gene_expression_purenoise <- matrix(rpois(N_samples*N_genes,1), ncol=N_samples)
rownames(gene_expression_purenoise) <- rownames(adj_matrix)
colnames(gene_expression_purenoise) <- paste0('sample', 1:N_samples)

pheatmap(log2(gene_expression_purenoise+1), show_rownames = FALSE, show_colnames=FALSE, cluster_rows = FALSE, cluster_cols = FALSE)
```

And using netSmooth:

```{r}
gene_expression_purenoise_smoothed <- netSmooth(gene_expression_purenoise, adj_matrix, alpha=0.9, normalizeAdjMatrix='columns')
yhat_purenoise.sm <- robustClusters(gene_expression_purenoise_smoothed, dimReduceFlavor='pca', combineManyProportion=.6, combineManyMinSize=10)

o <- order(yhat_purenoise.sm$clusters)
pheatmap(gene_expression_purenoise_smoothed[,o], cluster_rows = FALSE, cluster_cols = FALSE, show_rownames = FALSE, show_colnames = FALSE, annotation_col = data.frame(robustClusters=as.factor(yhat_purenoise.sm$clusters)))
```
```{r}
data.frame(clustering=c('robustClusters(pure noise)','robustClusters(with some signal)'), nmi=unlist(c(nmi(df2$block[yhat_purenoise.sm$clusters!=-1], yhat_purenoise.sm$clusters[yhat_purenoise.sm$clusters!=-1]), nmi(df2$block[yhat.sm$clusters!=-1], yhat.sm$clusters[yhat.sm$clusters!=-1]))))
```

-------

```

```{r}
sessionInfo()
```
